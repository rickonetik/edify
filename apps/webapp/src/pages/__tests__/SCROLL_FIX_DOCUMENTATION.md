# Исправление бага с восстановлением позиции скролла

## Проблема

При переходе на карту курса и возврате назад пользователя перебрасывало в начало страницы `/learn`, хотя он скроллил вниз. Также наблюдалось мигание верхней части страницы на миллисекунду перед восстановлением позиции.

## Анализ проблемы

### Основные причины:

1. **Позиция не сохранялась при переходе на карту**
   - При `navigate('/course/:id')` компонент `LearnPage` размонтировался
   - Cleanup функция в `useEffect` могла не успеть сохранить позицию
   - `scrollTop` мог быть уже 0 к моменту сохранения

2. **Позиция затиралась нулём**
   - При маунте компонента прилетал первый `scroll` event с `scrollTop=0`
   - Это перезаписывало сохранённую позицию > 0

3. **Восстановление происходило слишком поздно**
   - Восстановление в `useEffect` выполнялось после рендера
   - Браузер успевал отрисовать страницу с `scrollTop=0` перед восстановлением
   - Это вызывало видимое мигание

## Решение

### 1. Многоуровневая система сохранения позиции

**In-memory cache для быстрого доступа:**

```typescript
const scrollPositionCache = new Map<string, number>();
```

- Кэш в памяти для мгновенного доступа к позициям
- Синхронизируется с `sessionStorage`
- Fallback если `sessionStorage` недоступен или медленный

**Отслеживание последней известной позиции:**

```typescript
const lastKnownScrollRef = useRef<number>(0);
```

- Обновляется при каждом скролле
- Используется как fallback при unmount, если `el.scrollTop` уже 0

**Множественные точки сохранения:**

- При каждом событии `scroll` (debounce не нужен, `sessionStorage` быстрый)
- При `beforeunload` (перед навигацией/закрытием)
- При `pagehide` (переключение вкладок)
- При `visibilitychange` (скрытие страницы, важно для WebView)
- При изменении `location` в `useLayoutEffect` (до unmount)
- При unmount компонента (последний шанс)

### 2. Защита от затирания нулём

**Флаги блокировки сохранения:**

```typescript
const isRestoringRef = useRef(false); // Блокирует сохранение во время restore
const isInitializingRef = useRef(true); // Блокирует сохранение во время инициализации
```

**Проверка перед сохранением:**

```typescript
// Не сохранять 0, если есть сохранённая позиция > 0
if (currentScroll === 0 && savedValueRef.current !== null && savedValueRef.current > 0) {
  return;
}
```

### 3. Синхронное восстановление позиции

**Ключевое изменение - использование `useLayoutEffect`:**

```typescript
useLayoutEffect(() => {
  // Восстановление происходит СИНХРОННО до paint браузера
  if (shouldRestore) {
    el.scrollTop = target; // Устанавливается сразу, без RAF
    isRestoringRef.current = true;
  }
}, [location.pathname, location.search, navigationType]);
```

**Почему это работает:**

- `useLayoutEffect` выполняется синхронно после всех DOM мутаций, но ДО paint
- Браузер не успевает отрисовать страницу с неправильной позицией
- Нет видимого мигания

**Определение типа навигации:**

```typescript
const isPopNav = isPopNavigationRef.current || navigationType === 'POP';
const shouldRestorePop = isPopNav && hasSaved;
const shouldRestoreTab = isTab && hasSaved && savedValue > 0;
```

### 4. Логика восстановления

**Для POP навигации (назад/вперёд):**

- Восстанавливаем позицию, если она сохранена (даже если 0 - пользователь мог скроллить вверх)

**Для табов (переключение между `/learn`, `/library`, `/account`):**

- Восстанавливаем только если сохранённая позиция > 0
- Это предотвращает восстановление 0 при первом посещении таба

### 5. Улучшенная обработка unmount

**Сохранение при unmount:**

```typescript
return () => {
  const finalScroll = el.scrollTop || lastKnownScrollRef.current;
  if (finalScroll > 0 || (finalScroll === 0 && savedValue === 0)) {
    saveScrollPosition(scrollKey, String(finalScroll));
  }
};
```

- Использует `lastKnownScrollRef` как fallback
- Сохраняет даже если элемент уже частично размонтирован

## Архитектура решения

### Два этапа обработки:

1. **`useLayoutEffect` (синхронный, до paint):**
   - Сохранение позиции при изменении пути
   - Восстановление позиции
   - Установка начального `scrollTop`

2. **`useEffect` (асинхронный, после paint):**
   - Настройка слушателей событий
   - Асинхронная очистка флагов после restore
   - Cleanup при unmount

### Ключевые паттерны:

1. **Синхронное сохранение перед навигацией**
   - `useLayoutEffect` срабатывает до unmount
   - Позиция сохраняется до того, как React размонтирует компонент

2. **Синхронное восстановление**
   - Позиция устанавливается до paint
   - Нет видимого мигания

3. **Защита от race conditions**
   - Флаги блокируют сохранение во время restore
   - Проверки предотвращают затирание сохранённой позиции

4. **Множественные fallback'и**
   - In-memory cache
   - `lastKnownScrollRef`
   - `sessionStorage`

## Результат

✅ Позиция скролла сохраняется при переходе на карту курса  
✅ Позиция восстанавливается при возврате назад  
✅ Нет видимого мигания верхней части страницы  
✅ Работает для POP навигации и переключения табов  
✅ Защита от затирания позиции нулём

## Возможные улучшения

1. **Debounce для сохранения при скролле** (опционально)
   - Сейчас сохраняется при каждом `scroll` event
   - Можно добавить debounce для уменьшения записей в `sessionStorage`

2. **Индикатор загрузки** (если нужно)
   - Если восстановление занимает время, можно показать skeleton

3. **Анимация восстановления** (опционально)
   - Плавная прокрутка к сохранённой позиции вместо мгновенной

4. **Очистка старых позиций**
   - Уже реализовано через `cleanupOldScrollKeys()`
   - Можно добавить TTL для позиций

5. **Метрики и мониторинг**
   - Логирование в production для отладки
   - Отслеживание случаев, когда восстановление не сработало
