# Финальный чеклист тестирования Scrollable перед merge

## Текущая реализация

**Ключевые особенности:**

- Для табов (`/learn`, `/library`, `/account`): используется `pathname` как стабильный ключ
- Для других роутов: используется `location.key` (уникальный для каждой записи в истории)
- Сохранение при изменении `scrollKey` в `useLayoutEffect` (синхронно до unmount)
- Сохранение при unmount в cleanup `useEffect` (fallback)
- Восстановление синхронно в `useLayoutEffect` (без мигания)
- Защита от сохранения во время restore (`isRestoringRef`)

## Тесты для проверки

### A) Back со стаба (главный баг) ⚠️ КРИТИЧНО

**Сценарий:**

1. Открыть `/learn`
2. Скроллить вниз до секции "Новости" (или любой другой контент внизу)
3. Нажать на любую заглушку (новость/урок/курс)
4. Нажать "Назад"
5. **Ожидание:** вернулись в ту же позицию, не наверх

**Повторить:** 5-10 раз подряд

**Как это работает:**

- При переходе на stub: `scrollKey` меняется с `scroll-/learn` на `scroll-<location.key>`
- `useLayoutEffect` сохраняет позицию для `scroll-/learn`
- При возврате назад: `scrollKey` снова `scroll-/learn`
- Восстанавливается позиция из `scroll-/learn`

**Потенциальная проблема:**

- Если cleanup не успевает сохранить позицию, может быть потеряна

### B) Переключение табов

**Сценарий:**

1. Открыть `/learn`
2. Скроллить вниз
3. Переключиться на `/library`
4. Вернуться на `/learn`
5. **Ожидание:** позиция восстановилась

**Как это работает:**

- Оба таба используют `pathname` как ключ
- При переходе `/learn` → `/library`: `scrollKey` меняется с `scroll-/learn` на `scroll-/library`
- `useLayoutEffect` сохраняет позицию для `scroll-/learn`
- При возврате на `/learn`: `scrollKey` снова `scroll-/learn`
- Восстанавливается позиция из `scroll-/learn`

### C) Быстрые действия (race-condition)

**Сценарий:**

1. На `/learn` скроллить вниз
2. Быстро тапнуть по табу (например, `/library`)
3. Сразу Back
4. Снова тап по табу
5. Снова Back
6. **Ожидание:** не "прыгает" наверх случайно

**Как это работает:**

- Каждое переключение сохраняет позицию синхронно в `useLayoutEffect`
- `isRestoringRef` защищает от сохранения во время restore
- `lastKnownScrollRef` используется как fallback

### D) Разные query параметры

**Сценарий:**

1. Открыть `/learn?state=loading`
2. Потом открыть `/learn` (без query)
3. Скроллить вниз
4. Перейти на stub
5. Нажать Back
6. **Ожидание:** restore не ломается из-за search

**Как это работает:**

- Для табов используется только `pathname`, игнорируется `search`
- `/learn?state=loading` и `/learn` используют один и тот же ключ `scroll-/learn`
- Позиция сохраняется и восстанавливается правильно

### E) Telegram WebView (если доступно)

**Сценарий:**

- Открыть в Telegram Mini App
- Прогнать тесты A и B
- **Ожидание:** работает так же, как в браузере

**Потенциальные проблемы:**

- WebView может иметь другие особенности работы с `location.key`
- Может потребоваться дополнительная проверка

## Что проверить в коде

1. ✅ Сохранение при изменении `scrollKey` в `useLayoutEffect`
2. ✅ Сохранение при unmount в cleanup `useEffect`
3. ✅ Восстановление синхронно в `useLayoutEffect`
4. ✅ Защита от сохранения во время restore
5. ✅ Fallback на `lastKnownScrollRef` если `el.scrollTop` уже 0
6. ✅ `location.pathname` в зависимостях `useEffect` для срабатывания cleanup при переходе на другую страницу

## Потенциальные проблемы

1. **Для табов с `replace: true`**: `location.key` не меняется, поэтому используется `pathname`
2. **При быстрых переключениях**: может быть race condition, но защита через `isRestoringRef` должна помочь
3. **В WebView**: `location.key` может работать по-другому, нужна проверка

## Готовность к merge

- ✅ Код упрощен (убраны лишние события)
- ✅ Используется `location.key` для не-табов
- ✅ Используется `pathname` для табов
- ✅ Синхронное восстановление без мигания
- ✅ Защита от race conditions
- ⚠️ Требуется ручное тестирование всех сценариев
