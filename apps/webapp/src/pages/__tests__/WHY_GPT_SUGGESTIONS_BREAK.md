# Почему предложенные упрощения ломают логику Scrollable

## Текущая рабочая версия (на основе location.key)

**Ключевая идея:**

- Для табов (`/learn`, `/library`, `/account`): используем `pathname` как стабильный ключ
- Для других роутов: используем `location.key` (уникальный для каждой записи в истории)

**Почему это работает:**

- `location.key` уникален для каждой навигации в истории браузера
- При возврате назад (`POP`) мы получаем тот же `location.key`, что был при первом посещении
- Для табов с `replace: true` `location.key` не меняется, поэтому используем `pathname`

## Проблемы с предложенными упрощениями

### 1. ❌ "Убрать все события кроме scroll и cleanup"

**Предложение:**

```typescript
// Только scroll и cleanup
el.addEventListener('scroll', onScroll);
return () => save(); // cleanup
```

**Почему это ломает:**

- При переходе на карту (`navigate('/course/:id')`) компонент размонтируется
- `cleanup` в `useEffect` выполняется **после** того, как React уже начал размонтирование
- `el.scrollTop` может быть уже 0 или элемент уже частично размонтирован
- **Результат:** позиция не сохраняется или сохраняется как 0

**Почему текущая версия работает:**

- Используем `location.key` - при изменении `location` React создает новый key
- `useEffect` с зависимостью от `scrollKey` перезапускается
- Cleanup предыдущего эффекта сохраняет позицию для старого key
- Новый эффект восстанавливает позицию для нового key

### 2. ❌ "Убрать защиту от сохранения 0"

**Предложение:**

```typescript
const save = () => {
  saveScrollPosition(scrollKey, el.scrollTop); // всегда сохраняем, включая 0
};
```

**Почему это ломает:**

- При восстановлении `el.scrollTop = saved` может вызвать событие `scroll`
- Это событие срабатывает **до** того, как мы успели установить флаги
- Сохраняется 0 вместо сохраненной позиции > 0
- **Результат:** при возврате назад позиция всегда 0

**Почему текущая версия работает:**

- Используем `location.key` - при восстановлении это **новый** key (или тот же для POP)
- Если это новый key, нет сохраненной позиции, восстанавливать нечего
- Если это тот же key (POP), восстанавливаем синхронно в `useLayoutEffect`
- События `scroll` от восстановления не сохраняются, потому что это новый эффект с новым key

### 3. ❌ "Использовать flush-события"

**Предложение:**

```typescript
// В BottomTabs, LearnPage и т.д.
window.dispatchEvent(new Event('scrollable:flush'));
navigate(path);
```

**Почему это ломает:**

- Требует изменений во **всех** местах навигации
- Если забыть добавить flush в одном месте - позиция потеряется
- Flush должен сработать **до** navigate, но события асинхронны
- Race condition: flush может не успеть обработаться до unmount
- **Результат:** хрупкая система, легко сломать при добавлении новых навигаций

**Почему текущая версия работает:**

- Не требует изменений в местах навигации
- Работает автоматически через React lifecycle
- `location.key` меняется синхронно при навигации
- Cleanup предыдущего эффекта гарантированно выполняется

### 4. ❌ "Убрать useLayoutEffect, использовать только useEffect"

**Предложение:**

```typescript
useEffect(() => {
  if (saved) {
    el.scrollTop = saved; // в useEffect, после paint
  }
}, [scrollKey]);
```

**Почему это ломает:**

- `useEffect` выполняется **после** paint браузера
- Браузер успевает отрисовать страницу с `scrollTop=0`
- Пользователь видит мигание верхней части страницы
- **Результат:** плохой UX, видимое мигание

**Почему текущая версия работает:**

- `useLayoutEffect` выполняется **до** paint
- Позиция устанавливается синхронно, браузер не успевает отрисовать неправильную позицию
- Нет видимого мигания

### 5. ❌ "Использовать только pathname для всех роутов"

**Предложение:**

```typescript
const scrollKey = `${SCROLL_STORAGE_PREFIX}${pathname}`; // для всех
```

**Почему это ломает:**

- При переходе `/learn` → `/course/1` → back → `/learn`
- Оба раза `/learn` имеет один и тот же `pathname`
- Позиция перезаписывается при каждом посещении
- **Результат:** при возврате назад восстанавливается последняя позиция, а не та, что была до перехода на карту

**Почему текущая версия работает:**

- Для не-табов используем `location.key`
- Каждое посещение `/learn` имеет уникальный `location.key`
- Позиция сохраняется для конкретного key
- При возврате назад восстанавливается позиция для того же key

### 6. ❌ "Убрать все флаги (isRestoring, isInitializing)"

**Предложение:**

```typescript
const save = () => {
  saveScrollPosition(scrollKey, el.scrollTop); // без проверок
};
```

**Почему это ломает:**

- При восстановлении `el.scrollTop = saved` вызывает событие `scroll`
- Это событие сохраняет позицию **до** того, как восстановление завершилось
- Может сохраниться промежуточное значение или 0
- **Результат:** позиция затирается во время восстановления

**Почему текущая версия работает:**

- Используем `location.key` - при восстановлении это новый эффект
- Старый эффект уже размонтирован, его cleanup уже сохранил позицию
- Новый эффект только восстанавливает, не сохраняет (пока не было скролла)

## Ключевое понимание: почему location.key решает проблемы

### Проблема race condition

**Старый подход (pathname-based):**

```
1. Пользователь на /learn, scrollTop = 500
2. Нажимает на карту → navigate('/course/1')
3. React начинает размонтировать LearnPage
4. Cleanup пытается сохранить, но scrollTop уже может быть 0
5. Позиция теряется
```

**Новый подход (location.key-based):**

```
1. Пользователь на /learn, location.key = "abc", scrollTop = 500
2. Скролл сохраняет: scroll-abc = 500
3. Нажимает на карту → navigate('/course/1')
4. location.key меняется на "def"
5. Cleanup эффекта для "abc" сохраняет: scroll-abc = 500 (гарантированно)
6. Новый эффект для "def" не находит сохраненной позиции
7. При возврате назад location.key снова "abc"
8. Восстанавливаем: scroll-abc = 500 ✅
```

### Почему не нужны флаги защиты

**С location.key:**

- Каждое изменение location создает новый key
- Новый key = новый эффект = новый scope
- События scroll от старого эффекта не влияют на новый
- Не нужно блокировать сохранение - старый эффект уже размонтирован

**Без location.key (pathname-based):**

- Один и тот же pathname = один и тот же эффект
- События scroll от восстановления влияют на тот же эффект
- Нужны флаги, чтобы блокировать сохранение во время restore

## Итоговая архитектура (правильная)

```typescript
// Ключ зависит от типа роута
const scrollKey = isTab
  ? `${SCROLL_STORAGE_PREFIX}${pathname}` // стабильный для табов
  : `${SCROLL_STORAGE_PREFIX}${location.key}`; // уникальный для других

// Восстановление синхронно (useLayoutEffect)
useLayoutEffect(() => {
  const saved = getScrollPosition(scrollKey);
  if (saved !== null) {
    el.scrollTop = saved; // до paint, без мигания
  }
}, [scrollKey]);

// Сохранение при скролле и cleanup
useEffect(() => {
  const save = () => saveScrollPosition(scrollKey, el.scrollTop);
  el.addEventListener('scroll', save);
  return () => save(); // гарантированное сохранение при unmount
}, [scrollKey]);
```

**Почему это работает:**

1. ✅ Нет race condition - cleanup выполняется для старого key, новый эффект для нового key
2. ✅ Нет затирания 0 - события scroll от восстановления не влияют (новый key = новый эффект)
3. ✅ Нет мигания - восстановление в useLayoutEffect синхронно
4. ✅ Не требует изменений в местах навигации - работает автоматически
5. ✅ Простой код - минимум флагов и проверок

## Вывод

Предложенные упрощения ломают логику, потому что:

- Они пытаются решить проблему на уровне событий и флагов
- Не учитывают, что React lifecycle и location.key уже решают эти проблемы
- Добавляют хрупкие зависимости (flush-события) вместо использования встроенных механизмов React Router

Правильное решение - использовать `location.key` как основу для ключей сохранения, что автоматически решает все проблемы race condition и затирания.
