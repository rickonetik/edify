---
name: rules
description: Project rules for tracked-lms (Cursor mandatory)
---

# Overview
Mandatory rules for all changes in tracked-lms. Follow them strictly to avoid architecture drift.
- Epic order is mandatory; see docs/runbooks/epics-outline.md
- Do not implement outside the current Story scope

# Project Rules (tracked-lms) — Mandatory

## Prime Directive (Scope Control)
- Follow scope boundaries strictly.
- If a task does not explicitly ask for it, DO NOT do it.
- No refactors, no renames, no dependency additions, no folder reshuffles unless explicitly requested by the current Story.
- If requirements are unclear or missing inputs, DO NOT guess. Ask for clarification or implement the smallest safe stub consistent with the Story.

## Execution Mode (PR Discipline)
- Work on exactly ONE Story per PR.
- Keep changes minimal and localized to the Story scope.
- End every PR with a final summary:
  1) changed files list
  2) commands run + results
  3) manual QA checklist results
  4) artifacts produced (logs/screens/recordings)

## Repo Structure Invariants (Do Not Break)
Do not change these paths without an explicit Story:
- apps/api
- apps/webapp
- apps/bot
- packages/shared
- infra
- docs
- tools
- .cursor
Do not rename packages, tsconfig files, or workspace structure unless the Story explicitly demands it.

## Configuration / Infra Safety
- Do NOT modify tooling configs (tsconfig/eslint/prettier/vite/turbo/docker-compose/github actions) unless the Story explicitly asks.
- If a config change is required, explain why and keep it minimal.
- Never change ports, service names, or env keys without explicit requirement.

## Code Ownership by Layer
### WebApp
- UI components live under: apps/webapp/src/**
- Data fetching is forbidden inside UI components.
- Data access must go through:
  - apps/webapp/src/shared/api/*
  - apps/webapp/src/shared/hooks/*
- No business logic in UI. UI only renders states and triggers actions via hooks.

### API
- Domain modules live under: apps/api/src/modules/<domain>
- Cross-cutting code lives under: apps/api/src/common/*
- Controllers must be thin: controllers delegate to services.
- Every endpoint must use the unified error format (no ad-hoc JSON).

### Bot
- Bot features live under: apps/bot/src/*
- Validate env at boot. Never start with missing BOT_TOKEN.
- Bot must not contain core business logic; it calls API or queues jobs.

### Shared (Single Source of Truth)
- packages/shared is the single source of truth for:
  - DTO/contracts
  - error codes and error response shape
  - env schemas
Never duplicate enums/DTOs/error codes in apps.

**TypeScript Paths Rule**: Do not add tsconfig paths for `@tracked/shared/*` or any deep paths. Only `@tracked/shared` root mapping is allowed. Wildcard paths are forbidden and will break typecheck without build.

## Foundation Freeze (EPIC 1+)

**CRITICAL**: Foundation infrastructure is frozen for EPIC 1 and beyond.

### Frozen Files/Directories (Do NOT modify in EPIC 1)

The following are **FORBIDDEN** to modify during EPIC 1 unless explicitly part of a `chore/foundation-*` Story:

- `tools/verify/*` - Quality gates verification scripts
- `tools/tests/foundation/*` - Foundation smoke tests
- `infra/docker-compose.yml` - Infrastructure configuration
- `tsconfig.base.json` - Base TypeScript configuration
- `packages/shared/tsconfig.json` - Shared package TypeScript configuration
- `.github/workflows/ci.yml` - CI/CD workflows (if exists)

### Exception Rule

**ONLY** modifications allowed via explicit Stories with format:
- Story name: `chore/foundation-*` (e.g., `chore/foundation-update-verify`, `chore/foundation-add-test`)
- Must have explicit DoD (Definition of Done)
- Must pass all existing quality gates after changes

### Why This Rule Exists

Cursor and AI assistants tend to "improve" infrastructure when working on features. This rule prevents:
- Accidental breaking of quality gates
- Unintended changes to test infrastructure
- Drift in TypeScript configuration
- CI/CD pipeline modifications without explicit approval

**If you need to change foundation infrastructure, create a separate Story first.**

## Architecture Rules (EPIC 1+)

### No Premature Abstraction

**Critical**: Do not introduce DI containers, layers, repositories, or factories "for future use" unless the Story explicitly requires them.

- One domain = one module (API) and one feature (WebApp)
- No "core/common domain services" until there are at least 2 real reuse cases
- Keep it simple: implement what's needed now, not what might be needed later

### Anti-Duplication: Single Source of Truth

All DTO/contracts/errors/env must come from `@tracked/shared`:

- In apps: import from `@tracked/shared`
- Do NOT copy enums, error codes, or response types
- Do NOT define `ErrorCodes` or `ApiErrorResponse` in apps
- Do NOT format errors manually in controllers (use `ApiExceptionFilter`)

### WebApp Structure Minimization

Until EPIC 1-2:

- Do NOT add separate "layers" like `domain/`, `services/`, `repositories/`
- Keep structure:
  - `src/app` (router/layout)
  - `src/pages`
  - `src/shared` (ui/theme/telegram/env/api later)
- `src/features` will appear only when real features exist (Learning/Library/Account)

### Architectural Check Commands

Before PR merge, run these and include output:

```bash
pnpm verify
rg "@tracked/shared/src" -n || true
rg "@tracked/shared/\\*" -n tsconfig*.json apps/**/tsconfig*.json packages/**/tsconfig*.json || true
rg "export enum ErrorCodes|VALIDATION_ERROR|INTERNAL_ERROR" apps -n || true
rg "statusCode\"\\s*:" apps/api/src -n || true
```

## Dependencies Policy (Strict)
- Do NOT add new libraries unless the Story explicitly says so.
- Prefer existing dependencies already in the repo.
- If a new dependency is unavoidable:
  - explain why
  - list at least 1 alternative
  - keep it to 1 library max for the Story

## Database / Migrations Discipline
- DB schema changes are allowed only when explicitly required by the Story.
- Migrations must be deterministic and committed.
- Do not introduce extra columns/tables “for future” unless requested.

## Environment Variables
- All apps must validate env on startup using shared schemas.
- Do not hardcode ports. Use env.
- Do not introduce new env keys unless required by the Story.

## Logging, Errors, and Security
- API must set/propagate x-request-id and include traceId in error responses.
- API errors must return:
  { statusCode, code, message, traceId, details? }
- Never leak secrets in logs.
- Do not store credentials, tokens, or secrets in code or git.
- Storage links:
  - Do not store raw public S3/MinIO URLs in DB unless explicitly allowed by the Story.
  - Prefer storing object keys + generating signed URLs on read (when in scope).

## Formatting & Linting
- Keep formatting consistent with repo configs.
- Do not reformat unrelated files.
- Changes must be minimal and localized.

## Git Discipline
- Branch naming: type/scope-short (e.g., chore/infra-compose)
- One Story = one PR.
- Commit messages should be conventional style when possible.

## Quality Gates Enforcement

### Before Starting Any New Story

1. **Run `pnpm verify`**
   - If red → fix first, stop
   - Do not proceed with new Story if verify fails

2. **Never modify unrelated files to make verify pass**
   - Fix the actual issue, not symptoms
   - Maintain scope discipline

### Quality Gates Check

The `pnpm verify` command runs:
- Workspace integrity check
- Deep imports check (no `@tracked/shared/src/*`)
- Lint (errors block, warnings OK)
- Typecheck
- Build

See [docs/runbooks/quality-gates.md](../docs/runbooks/quality-gates.md) for details.

## Stop Condition
After completing the current Story DoD and Manual QA, STOP.
Do not start the next Story.
